\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{float}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage[labelformat=empty]{caption}
\usepackage{booktabs}

\geometry{
	a4paper,
 	left=20mm,
 	top=20mm,
 	bottom=20mm,
}

\setlength{\parindent}{0pt}

\begin{document}

\section{Alphabete, W{\"o}rter und Sprachen}

\begin{description}[labelindent=16pt,style=multiline,leftmargin=5cm, noitemsep]
	\item[Alphabet $\Sigma$:] Eine endliche, nichtleere Menge bestehend aus \textbf{Buchstaben}
	\item[Wort:] Ein Wort {\"u}ber $\Sigma$ ist eine endliche Folge von Buchstaben. ($\Sigma^*$ ist die Menge aller W{\"o}rter)
	\item[Sprache $L$:] Eine Menge von W{\"o}rtern, also eine Teilmenge von $\Sigma^*$
\end{description}

F{\"u}r ein \textbf{Wort} in $\Sigma^*$ gilt:
\begin{equation*}
\begin{split}
	\textbf{Konkatenation:}\quad & \text{Kon}(x,y) = x \cdot y = xy \\
	\textbf{Reversal:} \quad & a^R = (a_1a_2...a_n)^R = a_na_{n-1}...a_1 \\
	\textbf{Exponent:} \quad & (abc)^3 = abcabcabc \\
	\textbf{Vorkommen:} \quad & |x = abcabcabc|_a = 3\quad\text{(Anzahl $a$ in $x$)} \\
	\textbf{kanonische Ordnung:} \quad & u < v \Leftrightarrow (|u| < |v|) \lor (|u| = |v| \land u = x \cdot s_i \cdot u' \land v = x \cdot s_j \cdot v') \quad\text{(mit $i < j$)} \\
\end{split}
\end{equation*}

F{\"u}r eine \textbf{Sprache} gilt:
\begin{equation*}
\begin{split}
	\textbf{Konkatenation:}\quad & L_1\cdot L_2 = L_1L_2 = \{vw\ |\ v \in L_1 \land w \in L_2\} \\
	\textbf{Exponent:}\quad & L^{i+1} = L^i\cdot L \\
	\textbf{Kleene'schen Stern:}\quad & L^* = \bigcup_{i\in\mathbb{N}}L^i
\end{split}
\end{equation*}

\subsection{Algorithmische Probleme}

\subsubsection{Entscheidungsproblem}
F{\"u}r jedes $x \in \Sigma^*$ ist zu entscheiden, ob $x \in L$ oder $x \notin L$. Ein \textbf{Algorithmus} $A$ l{\"o}st das Entscheidungsproblem $(\Sigma, L)$, falls f{\"u}r alle $x \in \Sigma^*$ gilt:
\begin{equation*}
	A(x) = \begin{cases}
		1, \quad\text{falls $x \in L$} \\
		0, \quad\text{falls $x \notin L$} \\
	\end{cases}
\end{equation*}

$A$ \textbf{erkennt} somit die Sprache. $L$ ist \textbf{rekursiv}, falls so ein Algorithmus $A$ existiert.

\subsubsection{Funktion (Transformation)}
Ein \textbf{Algorithmus} $A$ berechnet eine Funktion $f: \Sigma^* \mapsto \Gamma^*$, falls
\begin{equation*}
	A(x) = f(x) \quad\text{f{\"u}r alle $x \in \Sigma^*$}
\end{equation*}

Entscheidungsprobleme sind spezielle F{\"a}lle von Funktionsberechnungen.

\subsubsection{Relationsproblem}
Sei $R \subseteq \Sigma^*\times\Gamma^*$ eine Relation, dann l{\"o}st ein \textbf{Algorithmus} $A$ das Relationsproblem $R$, falls f{\"u}r alle $(x,y) \in R$ gilt:
\begin{equation*}
	(x, A(x)) \in R
\end{equation*}

\emph{Bemerkung:} Es ist nur n{\"o}tig, ein einziges $y = A(x)$ von potenziel unendlich vielen $y$ zu finden.
\subsection{Kolmogorov complexity}
\begin{enumerate}
	\item Write the function to give the desired output.
	\item Find the part of the program that depends on n() (we multiply the log with the number of times that n appears in the program).
	\item This part has complexity of $\ulcorner log_2(n + 1) \urcorner$ + c.
	\item Find $y_n$ in function of n and replace it in the previous part.
\end{enumerate}

\section{Endliche Automaten}

Ein \textbf{endlicher Automat} (EA) ist ein Tupel $M = (Q, \Sigma, \delta, q_0, F)$:
\begin{description}[labelindent=16pt,style=multiline,leftmargin=2.5cm, noitemsep]
	\item[$Q$:] Eine endliche Menge von Zust{\"a}nden
	\item[$\Sigma$:] Das Eingabealphabet
	\item[$q_0 \in Q$:] Der Anfangszustand
	\item[$F \subseteq Q$:] Die Menge der akzeptierenden Zust{\"a}nde (Zust{\"a}nde, die das momentan gelesene Wort als valid erkl{\"a}ren)
	\item[$\delta$:] Die {\"U}bergangsfunktion ($\delta: (Q\times\Sigma) \mapsto Q$)
\end{description}

Weiter definiert sind folgende:
\begin{description}[labelindent=16pt,style=multiline,leftmargin=7.5cm, noitemsep]
	\item[Konfiguration:] Ein Element aus $(Q \times \Sigma^*)$. Befindet sich $M$ in der Konfiguration $(q, w)$ , bedeutet das, dass $M$ im Zustand $q$ ist und noch das Suffix $w$ lesen soll.
	\item[Startkonfiguration:] Die Berechnung von $M$ auf $x$ muss in der Konfiguration $(q_0, x) \in (\{q_0\} \times \Sigma^*)$ anfangen
	\item[Endkonfiguration:] Jedes Element in $(Q \times \{\lambda\})$
	\item[Schritt:] Eine Relation auf Konfigurationen definiert als $(q,w) \vdash_M (p,x) \Leftrightarrow w = ax, a \in \Sigma$ und $\delta(q, a) = p$. Sie entspricht einer Anwendung der {\"U}bergangsfunktion auf die aktuelle Konfiguration.
	\item[Berechnung $C$:] Eine endliche Folge $C = C_0,C_1,C_2,...,C_n$ von Konfigurationen, so dass $C_i \vdash_M C_{i+1}$. Weiter ist $C$ eine \textbf{Berechnung von $M$ auf eine Eingabe $x \in \Sigma^*$}, falls $C_0$ eine Startkonfiguration und $C_n$ eine Endkonfiguration ist. Ist $C_n \in (F \times \{\lambda\})$, so ist $C$ eine \textbf{akzeptierende Berechnung} (im Gegensatz zu \textbf{verwerfenden Berechnungen}).
	\item[Akzeptierte Sprache $L(M)$:] $L(M) = \{ w \in \Sigma^*\ |$ die Berechnung auf $w$ endet in einer Endkonfiguration $(q, \lambda)$ mit $q \in F \}$
	\item[Klasse der regul{\"a}ren Sprachen $\mathcal{L}_{EA}$:] Die Klasse der Sprachen, die von endlichen Automaten akzeptiert werden. Jede Sprache in $\mathcal{L}_{EA}$ wird \textbf{regul{\"a}r} genannt.
\end{description}

Zus{\"a}tzliche sind folgende Operationen definiert:
\begin{description}[labelindent=16pt,style=multiline,leftmargin=4.5cm, noitemsep]
	\item[$\vdash^*_M$:] Die \emph{reflexive} und \emph{transitive} H{\"u}lle der Schrittrelation $\vdash_M$. $(q,w) \vdash^*_M (p,u)$ ist, dass es eine Berechnung von $M$ gibt, die ausgehend von der Konfiguration $(q,w)$ zu der Konfiguration $(p,u)$ f{\"u}hrt.
	\item[$\hat\delta: (Q \times \Sigma^*) \mapsto Q$:] (i) $\hat\delta(q,\lambda) = q$ f{\"u}r alle $q\in Q$ \\
	(ii) $\hat\delta(q, wa) = \delta(\hat\delta(q, w), a)$ \\
	Die Aussage $\hat\delta(q, w) = p$ bedeutet, dass wenn $M$ im Zustand $q$ das Wort $w$ zu lesen beginnt, dann endet $M$ im Zustand $p$.
\end{description}

Zwei endliche Automaten $A$ und $B$ heissen \textbf{{\"a}quivalent}, falls gilt:
\begin{equation*}
	L(A) = L(B)
\end{equation*}

\subsection{Nichtexistenz}

Um zu zeigen, dass eine Sprache nicht regul{\"a}r ist ($L \notin \mathcal{L}_{EA}$), gen{\"u}gt es, zu beweisen, dass es keinen Automaten gibt, der die Sprache akzeptiert.

\subsubsection{Lemma 3.3}

Sei $A = (Q, \Sigma, \delta_A, q_0, F)$ ein EA. Seien weiter $x,y \in \Sigma^*$ mit $x \neq y$, wobei $x$ und $y$ nicht unbedingt in $L$ sein muss, so dass
\begin{equation*}
	(q_0, x) \vdash_A^* (p, \lambda)\quad\text{und}\quad (q_0, y) \vdash_A^* (p, \lambda)
\end{equation*}

Das heisst, dass nach dem Lesen der unterschiedlichen W{\"o}rter $x$ und $y$ der EA im gleichen Zustand endet. Daraus folgt, dass der EA in Zukunft zwischen den W{\"o}rtern nicht unterscheiden kann. Anders ausgedr{\"u}ckt:

\begin{equation*}
	\hat\delta_A(q_0, x) = \hat\delta_A(q_0, y) = p \quad (x, y \in \text{Kl}[p])
\end{equation*}

F{\"u}r jedes Suffix $z \in \Sigma^*$ gilt dann, dass beide W{\"o}rter $xz$ und $yz$ entweder akzeptiert oder beide verworfen werden, ansonsten ist die Sprache nicht regul{\"a}r:

\begin{equation*}
	xz \in L(A) \Leftrightarrow yz \in L(A)
\end{equation*}

\paragraph{Vorgehen:} Um zu beweisen, dass eine Sprache nicht regul{\"a}r ist, zeigt man, dass zwei W{\"o}rter zum selben Zustand f{\"u}hren m{\"u}ssen.\\
	We set m = to the number of states in the FSM. Then we take M+1 words that are all accepted. Since there are m+1 words there has to be two different words that bring to the same state departing from a $y_0$. Therefore both of them appended with a z have to belong to L. Then we just choose a z that works for one of them but not both.

\subsubsection{Pumping Lemma f{\"u}r regul{\"a}re Sprachen}

Sei $L$ regul{\"a}r, dann existiert eine Konstante $n_0 \in \mathbb{N}$, so dass sich jedes Wort $w \in \Sigma^*$ mit $|w| \geq n_0$ in drei Teile $x, y, z$ zerlegen l{\"a}sst, so dass $w = xyz$, wobei

\begin{enumerate}[label=(\roman*), noitemsep]
	\item $|xy| \leq n_0$
	\item $|x| \geq 1$
	\item entweder $\{yx^kz\ |\ k \in \mathbb{N}\} \subseteq L$ oder $\{yx^kz\ |\ k \in \mathbb{N}\} \cap L = \emptyset$
\end{enumerate}

\paragraph{Vorgehen:} W{\"a}hle ein Wort mit L{\"a}nge $|w| \geq n_0 \in \mathbb{N}$ aus, so dass keine seiner Zerlegungen die Eigenschaften (i), (ii) und (iii) erf{\"u}llt.

\subsection{Methode der Kolmogorov Komplexit{\"a}t}

Sei $L \subseteq \Sigma_\text{bool}^*$ eine regul{\"a}re Sprache. Sei $L_x = \{y \in \Sigma_\text{bool}^*\ |\ xy \in L\}$ f{\"u}r jedes $x \in \Sigma_\text{bool}^*$. Dann existiert eine Konstante const, so dass f{\"u}r alle $x,y \in \Sigma_\text{bool}^*$ gilt

\begin{equation*}
	K(y) \leq \lceil\log_2(n+1)\rceil + \text{const}
\end{equation*}

falls $y$ das $n$-te Wort in der Sprache $L$ ist.

\subsection{Reguläre Ausdrücke}

Die Menge $RA(\Sigma)$ aller regulären Ausdrücke über dem Alphabet $\Sigma$ ist rekursiv definiert durch:
\begin{equation*}
\begin{split}
	\lambda \in RA(\Sigma),\ \emptyset \not\in RA(\Sigma) \qquad & L(\lambda) = \{\lambda\},\ L(\emptyset) = \{\emptyset\} \\
	a \in RA(\Sigma) \text{ für alle } a \in \Sigma \qquad & L(a) = \{a\} \\
	\alpha, \beta \in RA(\Sigma) \Rightarrow (\alpha, \beta) \in RA(\Sigma) \qquad & L(\alpha, \beta) = L(\alpha) \cdot L(\beta) \\
	\alpha, \beta \in RA(\Sigma) \Rightarrow (\alpha + \beta) \in RA(\Sigma) \qquad & L(\alpha + \beta) = L(\alpha) \cup L(\beta) \\
	\alpha \in RA(\Sigma) \Rightarrow \alpha^* \in RA(\Sigma) \qquad & L(\alpha^*) = (L(\alpha))^*
\end{split}
\end{equation*}

Sei $\alpha_{ij}^{(k)}$ der reguläre Ausdruck, der alle Transitionen vom Zustand $i$ zu Zustand $j$ über die Zwischenzustände $k \in \{0,...,k\}$ beschreibt. Das heisst, es wird kein Zwischenzustand (Start- und Endzustand ausgenommen) $q$ berührt, mit $q > k$.

\begin{equation*}
	\alpha_{ij}^{(k)} = \alpha_{ij}^{(k-1)} + \alpha_{ik}^{(k-1)}\cdot (\alpha_{kk}^{(k-1)})^* \cdot \alpha_{kj}^{(k-1)}
\end{equation*}
	
\subsection{Nichtdeterminismus}	

Ein \textbf{nichtdeterministischer endlicher Automat} (NEA) ist wie ein endlicher Automat ein Tupel $M = (Q, \Sigma, \delta, q_0, F)$. Der einzige Unterschied ist, dass ein NEA zu einem Zustand $q$ und gelesenen Zeichen $a$ zu mehreren oder gar keinem Zustand {\"u}bergehen kann. \\
Dementsprechend ist $x$ in $L(M)$, falls es mindestens eine akzeptierte Berechnung auf $x$ gibt. Zus{\"a}tzlich kann eine nicht akzeptierte Berechnung auch fr{\"u}hzeitig enden, falls von dem momentanen Zustand $q$ keine weiteren Zust{\"a}nde f{\"u}r das gelesene Zeichen gibt ($\delta(q, a) = \emptyset$).

\begin{equation*}
	L(M) = \{w \in \Sigma^*\ |\ \hat\delta(q, a) \cap F \neq \emptyset\}
\end{equation*}

Ausserdem gilt $\mathcal{L}_{NEA} = \mathcal{L}_{EA}$: Zu jedem NEA $M$ existiert ein EA $A$, so dass
\begin{equation*}
	L(M) = L(A)
\end{equation*}

\subsubsection{$\lambda$-NEA}

$\lambda$-NEAs sind genau gleich definiert wie NEAs, also auch ein Tupel $M = (Q, \Sigma, \delta, q_0, F)$. Die Übergangsfunktion $\delta$ ist jedoch wie folgt definiert:
\begin{equation*}
	\delta: (Q\times(\Sigma \cup \{\lambda\})) \mapsto Q
\end{equation*}
Es kann also zusätzlich auch dass leere Wort $\lambda$ eingelesen werden. \\

Durch die Elimination der $\lambda$-Kanten lässt sich auch zeigen, dass $\mathcal{L}_{\lambda-NEA} = \mathcal{L}_{NEA}$.

\section{Grammatiken}

Eine Grammatik $G = (\Sigma_N, \Sigma_T, P, S)$ ist ein Tupel mit $\Sigma = \Sigma_N \cup \Sigma_T$:

\begin{description}[labelindent=16pt,style=multiline,leftmargin=3cm, noitemsep]
	\item[$\Sigma_N$:] Die Nichtterminalsymbole spielen die Rolle von Variablen und dürfen in der Sprache nicht vorkommen.
	\item[$\Sigma_T$:] Die Terminalsymbole, die bisherige Nutzung zur Gestaltung von Wörtern aus der betrachteten Sprache.
	\item[$S \in \Sigma_N$:] Das Startsymbol
	\item[$P$:] Die Menge der Ableitungsregeln ist eine Teilmenge von $\Sigma^*\Sigma_N\Sigma^* \times \Sigma^*$
	\item[$(\alpha, \beta) \in P$:] Die Regel, die besagt, dass $\alpha$ kann in $G$ durch $\beta$ ersetzt werden (auch $\alpha \rightarrow_G \beta$)
\end{description}

Sei weiter $\gamma, \delta \in \Sigma^*$, dann sagen wir dass $\delta$ aus $\gamma$ in einem Ableitungsschritt in $G$ ableitbar ist, genau dann wenn $w_1$ und $w_2 \in \Sigma^*$ und eine Regel $(\alpha, \beta) \in P$ existieren, so dass
\begin{equation*}
	\gamma \Rightarrow_G \delta :\Leftrightarrow \gamma = w_1\alpha w_2 \text{ und } w_1\beta w_2
\end{equation*}

Weiter bedeutet, $S \Rightarrow_G^* w$, dass $w$ von $G$ erzeugt wird. Die von $G$ erzeugte Sprache ist:
\begin{equation*}
	L(G) = \{w \in \Sigma^*_T\ |\ S \Rightarrow_G^* w\}
\end{equation*}

\begin{description}[labelindent=16pt,style=multiline,leftmargin=5.5cm, noitemsep]
	\item[Typ-0:] Die Klasse der allgemeinen, uneingeschränkten Grammatiken
	\item[kontextsensitiv/Typ-1:] $|\alpha| \leq |\beta|$ für alle Regeln $(\alpha, \beta) \in P$. Es folgt, dass mein kein Teilwort $\alpha$ durch ein kürzeres Teilwort $\beta$ ersetzen kann.
	\item[kontextfrei/Typ-2:] $\alpha \in \Sigma_N$ und $\beta \in \Sigma^*$ für alle Regeln $(\alpha, \beta) \in P$. Es folgt, dass alle Regeln die Form $X \rightarrow \beta$ für ein Nichtterminal $X$ haben.
	\item[regulär/Typ-3:] $\alpha \in \Sigma_N$ und $\beta \in \Sigma_T^*\cdot\Sigma_N \cup \Sigma_T^*$ für alle Regeln $(\alpha, \beta) \in P$. Das bedeutet, dass die Regeln die Form $X \rightarrow u$ oder $X \rightarrow uY$ für ein $u \in \Sigma_T^*, X,Y \in \Sigma_N$ haben (enthält höchstens ein Nichtterminal welches nur als letztes Symbol vorkommen darf).
	\item[normiert:] falls alle Regeln nur eine der folgenden drei Regeln haben:
	\begin{enumerate}[label=(\roman*), noitemsep]
		\item $S \rightarrow \lambda$, wobei S das Startsymbol ist
		\item $A \rightarrow a$ für $A \in \Sigma_N$ und $a \in \Sigma_T$
		\item $B \rightarrow bC$ für $B,C \in \Sigma_N$ und $b \in \Sigma_T$ 
	\end{enumerate}
\end{description}

Es gilt:
\begin{equation*}
	\mathcal{L}_3 = \mathcal{L}_{EA}
\end{equation*}

\end{document}
